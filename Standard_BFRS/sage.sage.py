
# This file was *autogenerated* from the file sage.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4); _sage_const_256 = Integer(256); _sage_const_8 = Integer(8); _sage_const_13 = Integer(13); _sage_const_11 = Integer(11); _sage_const_1073741969 = Integer(1073741969); _sage_const_15 = Integer(15); _sage_const_9 = Integer(9)#q = 7681
#q = 8388593
#q = 8000033
q = _sage_const_1073741969 
#q = 1032193
#q = 17
#q = 134218289
#q = 33554641
#q = 13
n = _sage_const_256 
#n = 512
r = _sage_const_8 
log_r = _sage_const_3 
K = ceil(log(q, _sage_const_2 ))
d = _sage_const_2 
m = d * (K + _sage_const_2 )

ZZx = ZZ['xz']; (xz,) = ZZx._first_ngens(1)
GFq = GF(q)
R = GF(q)['xx']; (xx,) = R._first_ngens(1)
Rq = R.quotient_ring((xx**(n) + _sage_const_1 ), names=('x',)); (x,) = Rq._first_ngens(1)

def my_ext_euclid(f, g):
	(r0, r1, v0, v1) = (g, f, R(_sage_const_0 ), R(_sage_const_1 ))
	while r0.degree() != _sage_const_0 :
		(q, r) = r0.quo_rem(r1)
		(v0, v1) = (v1, v0 - q*v1)
		(r0, r1) = (r1, r0 - q*r1)
		print "q\n", q, "\nr\n", r, "\nv0\n", v0, "\nv1\n", v1, "\nr0\n", r0, "\nr1\n", r1, "\n"

def cyclotomic_factorisation_tree(n):
    tree = [[GFq(_sage_const_1 )]]
    i = _sage_const_1 
    for i in range(_sage_const_1 , n):
        primitive_roots = []
        for r in tree[i-_sage_const_1 ]:
            primitive_roots += (-r).square_root(extend=False, all=True)
        tree.append(primitive_roots)
    return tree

def bezout_coefficients_tree(c_tree):
    b_tree = [[_sage_const_0 ]]
    for i in range(_sage_const_1 , len(c_tree)):
        b_tree.append(_sage_const_2 **i*[_sage_const_0 ])
        for j in range(_sage_const_2 **(i-_sage_const_1 )):
            #inv1 = (c_tree[i][2*j] - c_tree[i][2*j+1]).inverse_of_unit()
            inv1 = GFq((ZZ(c_tree[i][_sage_const_2 *j] - c_tree[i][_sage_const_2 *j+_sage_const_1 ])).inverse_mod(q))
            b_tree[i][_sage_const_2 *j] = inv1
            b_tree[i][_sage_const_2 *j+_sage_const_1 ] = -inv1
    return b_tree

def flatten_tree(tree):
    l = []
    for list in tree:
        l += list
    return l

def ext_euclid(f, nb):
    (r0, r1, v0, v1) = (xx**n + _sage_const_1 , f, R(_sage_const_0 ), R(_sage_const_1 ))
    for i in range(nb):
        (quo, rem) = r0.quo_rem(r1)
        (r0, r1) = (r1, rem)
        (v0, v1) = (v1, v0 - quo * v1)
    return (r0, r1, quo, v0, v1)

def crt(f):
	crt_f = [R(f.list()).quo_rem(c_f)[_sage_const_1 ].list() for c_f in cyclo_factors]
	return [crt_f_i if crt_f_i != [] else [_sage_const_0 ] for crt_f_i in crt_f]

def my_norm(v):
	coeffs = [ZZ(v_ij) for v_i in v.list() for v_ij in v_i]
	centered_v = vector(ZZ, [v_ij if v_ij < q/_sage_const_2  else (v_ij - q) for v_ij in coeffs])
	return centered_v.norm()

c_tree = cyclotomic_factorisation_tree(log_r + _sage_const_1 )
b_tree = bezout_coefficients_tree(c_tree)

print flatten_tree(c_tree)
print flatten_tree(b_tree)

cyclo_factors = [xx**(n/r) + c for c in c_tree[-_sage_const_1 ]]

Rx = RLF['xxr']; (xxr,) = Rx._first_ngens(1)
Rr = Rx.quotient_ring((xxr**n + _sage_const_1 ), names=('xr',)); (xr,) = Rr._first_ngens(1)
Cx = CIF['xxc']; (xxc,) = Cx._first_ngens(1)
Rc = Cx.quotient_ring((xxc**n + _sage_const_1 ), names=('xc',)); (xc,) = Rc._first_ngens(1)

if(n == _sage_const_8 ):
	cplx_prim_roots = [-e**(I*k*pi/n) for k in [_sage_const_3 , _sage_const_11 , _sage_const_15 , _sage_const_7 , _sage_const_13 , _sage_const_5 , _sage_const_1 , _sage_const_9 ]]
	cplx_roots = [[_sage_const_1 ], [I, -I], [-e**(I*k*pi/_sage_const_4 ) for k in [_sage_const_7 , _sage_const_3 , _sage_const_1 , _sage_const_5 ]], cplx_prim_roots]

def stride(f):
	return Cx([f[i] for i in range(_sage_const_0 , len(f.list()), _sage_const_2 )]), Cx([f[i] for i in range(_sage_const_1 , len(f.list()), _sage_const_2 )])

def inv_cplx_crt(f):
	return Cx.lagrange_polynomial(zip(cplx_prim_roots, f))

def is_almost_real(f):
	return max([abs(f_i.imag()) for f_i in f])

def cplx_crt(f):
	return Rc([Cx(f.list())(w) for w in cplx_prim_roots])

def matrix_cplx_crt(A):
	return A.apply_map(cplx_crt)

def extend_matrix(A):
	return block_matrix([[a.matrix().T for a in r] for r in A.rows()])

def poly_matrix(A):
	return matrix(Rr, [[A[i:i+n, j].list() for j in range(_sage_const_0 , A.ncols(), n)] for i in range(_sage_const_0 , A.nrows(), n)])

stored_A = matrix(Rq)


T = matrix(Rc)

p = matrix()

h_m = Rq()

if stored_A.dimensions() != (d, m-d):
	print "wrong dimensions for A"
	exit

if T.dimensions() != (_sage_const_2 *d, d*K):
	print "wrong dimensions for T"
	exit

A = block_matrix([[_sage_const_1 , stored_A]])
TI = block_matrix([[T], [_sage_const_1 ]])

g = matrix(Rq, [_sage_const_2 **i for i in range(K)])
G = block_diagonal_matrix([g for i in range(d)])

def construct_A_m(A, h_m):
	zero_matrix = matrix(Rq, d, _sage_const_2 *d, _sage_const_0 )
	return A + block_matrix([[zero_matrix, h_m * G]])


